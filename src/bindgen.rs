/* automatically generated by rust-bindgen 0.69.4 */

pub const _O_THEORA_THEORADEC_H_: u32 = 1;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140400;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const _O_THEORA_CODEC_H_: u32 = 1;
pub const TH_EFAULT: i32 = -1;
pub const TH_EINVAL: i32 = -10;
pub const TH_EBADHEADER: i32 = -20;
pub const TH_ENOTFORMAT: i32 = -21;
pub const TH_EVERSION: i32 = -22;
pub const TH_EIMPL: i32 = -23;
pub const TH_EBADPACKET: i32 = -24;
pub const TH_DUPFRAME: u32 = 1;
pub const TH_NHUFFMAN_TABLES: u32 = 80;
pub const TH_NDCT_TOKENS: u32 = 32;
pub const TH_DECCTL_GET_PPLEVEL_MAX: u32 = 1;
pub const TH_DECCTL_SET_PPLEVEL: u32 = 3;
pub const TH_DECCTL_SET_GRANPOS: u32 = 5;
pub const TH_DECCTL_SET_STRIPE_CB: u32 = 7;
pub const TH_DECCTL_SET_TELEMETRY_MBMODE: u32 = 9;
pub const TH_DECCTL_SET_TELEMETRY_MV: u32 = 11;
pub const TH_DECCTL_SET_TELEMETRY_QI: u32 = 13;
pub const TH_DECCTL_SET_TELEMETRY_BITS: u32 = 15;
pub const OV_FALSE: i32 = -1;
pub const OV_EOF: i32 = -2;
pub const OV_HOLE: i32 = -3;
pub const OV_EREAD: i32 = -128;
pub const OV_EFAULT: i32 = -129;
pub const OV_EIMPL: i32 = -130;
pub const OV_EINVAL: i32 = -131;
pub const OV_ENOTVORBIS: i32 = -132;
pub const OV_EBADHEADER: i32 = -133;
pub const OV_EVERSION: i32 = -134;
pub const OV_ENOTAUDIO: i32 = -135;
pub const OV_EBADPACKET: i32 = -136;
pub const OV_EBADLINK: i32 = -137;
pub const OV_ENOSEEK: i32 = -138;
pub const TF_EUNKNOWN: i32 = -1;
pub const TF_EUNSUPPORTED: i32 = -2;
pub const TF_ENODATASOURCE: i32 = -3;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type ogg_int16_t = i16;
pub type ogg_uint16_t = u16;
pub type ogg_int32_t = i32;
pub type ogg_uint32_t = u32;
pub type ogg_int64_t = i64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_iovec_t {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_ogg_iovec_t() {
    const UNINIT: ::std::mem::MaybeUninit<ogg_iovec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ogg_iovec_t>(),
        16usize,
        concat!("Size of: ", stringify!(ogg_iovec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_iovec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_iovec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_iovec_t),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iov_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_iovec_t),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct oggpack_buffer {
    pub endbyte: ::std::os::raw::c_long,
    pub endbit: ::std::os::raw::c_int,
    pub buffer: *mut ::std::os::raw::c_uchar,
    pub ptr: *mut ::std::os::raw::c_uchar,
    pub storage: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_oggpack_buffer() {
    const UNINIT: ::std::mem::MaybeUninit<oggpack_buffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<oggpack_buffer>(),
        40usize,
        concat!("Size of: ", stringify!(oggpack_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<oggpack_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(oggpack_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endbyte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(endbyte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).endbit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(endbit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(oggpack_buffer),
            "::",
            stringify!(storage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_page {
    pub header: *mut ::std::os::raw::c_uchar,
    pub header_len: ::std::os::raw::c_long,
    pub body: *mut ::std::os::raw::c_uchar,
    pub body_len: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ogg_page() {
    const UNINIT: ::std::mem::MaybeUninit<ogg_page> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ogg_page>(),
        32usize,
        concat!("Size of: ", stringify!(ogg_page))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_page>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_page))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(header_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(body)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_len) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_page),
            "::",
            stringify!(body_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_stream_state {
    pub body_data: *mut ::std::os::raw::c_uchar,
    pub body_storage: ::std::os::raw::c_long,
    pub body_fill: ::std::os::raw::c_long,
    pub body_returned: ::std::os::raw::c_long,
    pub lacing_vals: *mut ::std::os::raw::c_int,
    pub granule_vals: *mut ogg_int64_t,
    pub lacing_storage: ::std::os::raw::c_long,
    pub lacing_fill: ::std::os::raw::c_long,
    pub lacing_packet: ::std::os::raw::c_long,
    pub lacing_returned: ::std::os::raw::c_long,
    pub header: [::std::os::raw::c_uchar; 282usize],
    pub header_fill: ::std::os::raw::c_int,
    pub e_o_s: ::std::os::raw::c_int,
    pub b_o_s: ::std::os::raw::c_int,
    pub serialno: ::std::os::raw::c_long,
    pub pageno: ::std::os::raw::c_long,
    pub packetno: ogg_int64_t,
    pub granulepos: ogg_int64_t,
}
#[test]
fn bindgen_test_layout_ogg_stream_state() {
    const UNINIT: ::std::mem::MaybeUninit<ogg_stream_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ogg_stream_state>(),
        408usize,
        concat!("Size of: ", stringify!(ogg_stream_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_stream_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_stream_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_storage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_fill) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).body_returned) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(body_returned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lacing_vals) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_vals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granule_vals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(granule_vals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lacing_storage) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lacing_fill) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lacing_packet) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lacing_returned) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(lacing_returned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header_fill) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(header_fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_o_s) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(e_o_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_o_s) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(b_o_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialno) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(serialno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pageno) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(pageno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetno) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(packetno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granulepos) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_stream_state),
            "::",
            stringify!(granulepos)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_packet {
    pub packet: *mut ::std::os::raw::c_uchar,
    pub bytes: ::std::os::raw::c_long,
    pub b_o_s: ::std::os::raw::c_long,
    pub e_o_s: ::std::os::raw::c_long,
    pub granulepos: ogg_int64_t,
    pub packetno: ogg_int64_t,
}
#[test]
fn bindgen_test_layout_ogg_packet() {
    const UNINIT: ::std::mem::MaybeUninit<ogg_packet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ogg_packet>(),
        48usize,
        concat!("Size of: ", stringify!(ogg_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_packet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packet) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(packet)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b_o_s) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(b_o_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_o_s) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(e_o_s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granulepos) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(granulepos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).packetno) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_packet),
            "::",
            stringify!(packetno)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ogg_sync_state {
    pub data: *mut ::std::os::raw::c_uchar,
    pub storage: ::std::os::raw::c_int,
    pub fill: ::std::os::raw::c_int,
    pub returned: ::std::os::raw::c_int,
    pub unsynced: ::std::os::raw::c_int,
    pub headerbytes: ::std::os::raw::c_int,
    pub bodybytes: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ogg_sync_state() {
    const UNINIT: ::std::mem::MaybeUninit<ogg_sync_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ogg_sync_state>(),
        32usize,
        concat!("Size of: ", stringify!(ogg_sync_state))
    );
    assert_eq!(
        ::std::mem::align_of::<ogg_sync_state>(),
        8usize,
        concat!("Alignment of ", stringify!(ogg_sync_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).returned) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(returned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unsynced) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(unsynced)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).headerbytes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(headerbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bodybytes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ogg_sync_state),
            "::",
            stringify!(bodybytes)
        )
    );
}
extern "C" {
    pub fn oggpack_writeinit(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_writecheck(b: *mut oggpack_buffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn oggpack_writetrunc(b: *mut oggpack_buffer, bits: ::std::os::raw::c_long);
}
extern "C" {
    pub fn oggpack_writealign(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_writecopy(
        b: *mut oggpack_buffer,
        source: *mut ::std::os::raw::c_void,
        bits: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn oggpack_reset(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_writeclear(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_readinit(
        b: *mut oggpack_buffer,
        buf: *mut ::std::os::raw::c_uchar,
        bytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpack_write(
        b: *mut oggpack_buffer,
        value: ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpack_look(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_look1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_adv(b: *mut oggpack_buffer, bits: ::std::os::raw::c_int);
}
extern "C" {
    pub fn oggpack_adv1(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpack_read(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_read1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_bytes(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_bits(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpack_get_buffer(b: *mut oggpack_buffer) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn oggpackB_writeinit(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_writecheck(b: *mut oggpack_buffer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn oggpackB_writetrunc(b: *mut oggpack_buffer, bits: ::std::os::raw::c_long);
}
extern "C" {
    pub fn oggpackB_writealign(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_writecopy(
        b: *mut oggpack_buffer,
        source: *mut ::std::os::raw::c_void,
        bits: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn oggpackB_reset(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_writeclear(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_readinit(
        b: *mut oggpack_buffer,
        buf: *mut ::std::os::raw::c_uchar,
        bytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpackB_write(
        b: *mut oggpack_buffer,
        value: ::std::os::raw::c_ulong,
        bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn oggpackB_look(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_look1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_adv(b: *mut oggpack_buffer, bits: ::std::os::raw::c_int);
}
extern "C" {
    pub fn oggpackB_adv1(b: *mut oggpack_buffer);
}
extern "C" {
    pub fn oggpackB_read(
        b: *mut oggpack_buffer,
        bits: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_read1(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_bytes(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_bits(b: *mut oggpack_buffer) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn oggpackB_get_buffer(b: *mut oggpack_buffer) -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn ogg_stream_packetin(
        os: *mut ogg_stream_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_iovecin(
        os: *mut ogg_stream_state,
        iov: *mut ogg_iovec_t,
        count: ::std::os::raw::c_int,
        e_o_s: ::std::os::raw::c_long,
        granulepos: ogg_int64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_pageout(
        os: *mut ogg_stream_state,
        og: *mut ogg_page,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_pageout_fill(
        os: *mut ogg_stream_state,
        og: *mut ogg_page,
        nfill: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_flush(os: *mut ogg_stream_state, og: *mut ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_flush_fill(
        os: *mut ogg_stream_state,
        og: *mut ogg_page,
        nfill: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_init(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_clear(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_reset(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_destroy(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_check(oy: *mut ogg_sync_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_buffer(
        oy: *mut ogg_sync_state,
        size: ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ogg_sync_wrote(
        oy: *mut ogg_sync_state,
        bytes: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_sync_pageseek(oy: *mut ogg_sync_state, og: *mut ogg_page) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ogg_sync_pageout(oy: *mut ogg_sync_state, og: *mut ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_pagein(os: *mut ogg_stream_state, og: *mut ogg_page)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_packetout(
        os: *mut ogg_stream_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_packetpeek(
        os: *mut ogg_stream_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_init(
        os: *mut ogg_stream_state,
        serialno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_clear(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_reset(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_reset_serialno(
        os: *mut ogg_stream_state,
        serialno: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_destroy(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_check(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_stream_eos(os: *mut ogg_stream_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_checksum_set(og: *mut ogg_page);
}
extern "C" {
    pub fn ogg_page_version(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_continued(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_bos(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_eos(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_granulepos(og: *const ogg_page) -> ogg_int64_t;
}
extern "C" {
    pub fn ogg_page_serialno(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_page_pageno(og: *const ogg_page) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ogg_page_packets(og: *const ogg_page) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ogg_packet_clear(op: *mut ogg_packet);
}
#[doc = "The color space was not specified at the encoder.\nIt may be conveyed by an external means."]
pub const th_colorspace_TH_CS_UNSPECIFIED: th_colorspace = 0;
#[doc = "A color space designed for NTSC content."]
pub const th_colorspace_TH_CS_ITU_REC_470M: th_colorspace = 1;
#[doc = "A color space designed for PAL/SECAM content."]
pub const th_colorspace_TH_CS_ITU_REC_470BG: th_colorspace = 2;
#[doc = "The total number of currently defined color spaces."]
pub const th_colorspace_TH_CS_NSPACES: th_colorspace = 3;
#[doc = "The currently defined color space tags.\n See <a href=\"http://www.theora.org/doc/Theora.pdf\">the Theora\n  specification</a>, Chapter 4, for exact details on the meaning\n  of each of these color spaces."]
pub type th_colorspace = ::std::os::raw::c_uint;
#[doc = "Chroma decimation by 2 in both the X and Y directions (4:2:0).\nThe Cb and Cr chroma planes are half the width and half the\nheight of the luma plane."]
pub const th_pixel_fmt_TH_PF_420: th_pixel_fmt = 0;
#[doc = "Currently reserved."]
pub const th_pixel_fmt_TH_PF_RSVD: th_pixel_fmt = 1;
#[doc = "Chroma decimation by 2 in the X direction (4:2:2).\nThe Cb and Cr chroma planes are half the width of the luma plane, but full\nheight."]
pub const th_pixel_fmt_TH_PF_422: th_pixel_fmt = 2;
#[doc = "No chroma decimation (4:4:4).\nThe Cb and Cr chroma planes are full width and full height."]
pub const th_pixel_fmt_TH_PF_444: th_pixel_fmt = 3;
#[doc = "The total number of currently defined pixel formats."]
pub const th_pixel_fmt_TH_PF_NFORMATS: th_pixel_fmt = 4;
#[doc = "The currently defined pixel format tags.\n See <a href=\"http://www.theora.org/doc/Theora.pdf\">the Theora\n  specification</a>, Section 4.4, for details on the precise sample\n  locations."]
pub type th_pixel_fmt = ::std::os::raw::c_uint;
#[doc = "A buffer for a single color plane in an uncompressed image.\n This contains the image data in a left-to-right, top-down format.\n Each row of pixels is stored contiguously in memory, but successive\n  rows need not be.\n Use \\a stride to compute the offset of the next row.\n The encoder accepts both positive \\a stride values (top-down in memory)\n  and negative (bottom-up in memory).\n The decoder currently always generates images with positive strides."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_img_plane {
    #[doc = "The width of this plane."]
    pub width: ::std::os::raw::c_int,
    #[doc = "The height of this plane."]
    pub height: ::std::os::raw::c_int,
    #[doc = "The offset in bytes between successive rows."]
    pub stride: ::std::os::raw::c_int,
    #[doc = "A pointer to the beginning of the first row."]
    pub data: *mut ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_th_img_plane() {
    const UNINIT: ::std::mem::MaybeUninit<th_img_plane> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_img_plane>(),
        24usize,
        concat!("Size of: ", stringify!(th_img_plane))
    );
    assert_eq!(
        ::std::mem::align_of::<th_img_plane>(),
        8usize,
        concat!("Alignment of ", stringify!(th_img_plane))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_img_plane),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(th_img_plane),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(th_img_plane),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(th_img_plane),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "A complete image buffer for an uncompressed frame.\n The chroma planes may be decimated by a factor of two in either\n  direction, as indicated by th_info#pixel_fmt.\n The width and height of the Y' plane must be multiples of 16.\n They may need to be cropped for display, using the rectangle\n  specified by th_info#pic_x, th_info#pic_y, th_info#pic_width,\n  and th_info#pic_height.\n All samples are 8 bits.\n \\note The term YUV often used to describe a colorspace is ambiguous.\n The exact parameters of the RGB to YUV conversion process aside, in\n  many contexts the U and V channels actually have opposite meanings.\n To avoid this confusion, we are explicit: the name of the color\n  channels are Y'CbCr, and they appear in that order, always.\n The prime symbol denotes that the Y channel is non-linear.\n Cb and Cr stand for \"Chroma blue\" and \"Chroma red\", respectively."]
pub type th_ycbcr_buffer = [th_img_plane; 3usize];
#[doc = "Theora bitstream information.\n This contains the basic playback parameters for a stream, and corresponds to\n  the initial 'info' header packet.\n To initialize an encoder, the application fills in this structure and\n  passes it to th_encode_alloc().\n A default encoding mode is chosen based on the values of the #quality and\n  #target_bitrate fields.\n On decode, it is filled in by th_decode_headerin(), and then passed to\n  th_decode_alloc().\n\n Encoded Theora frames must be a multiple of 16 in size;\n  this is what the #frame_width and #frame_height members represent.\n To handle arbitrary picture sizes, a crop rectangle is specified in the\n  #pic_x, #pic_y, #pic_width and #pic_height members.\n\n All frame buffers contain pointers to the full, padded frame.\n However, the current encoder <em>will not</em> reference pixels outside of\n  the cropped picture region, and the application does not need to fill them\n  in.\n The decoder <em>will</em> allocate storage for a full frame, but the\n  application <em>should not</em> rely on the padding containing sensible\n  data.\n\n It is also generally recommended that the offsets and sizes should still be\n  multiples of 2 to avoid chroma sampling shifts when chroma is sub-sampled.\n See <a href=\"http://www.theora.org/doc/Theora.pdf\">the Theora\n  specification</a>, Section 4.4, for more details.\n\n Frame rate, in frames per second, is stored as a rational fraction, as is\n  the pixel aspect ratio.\n Note that this refers to the aspect ratio of the individual pixels, not of\n  the overall frame itself.\n The frame aspect ratio can be computed from pixel aspect ratio using the\n  image dimensions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_info {
    pub version_major: ::std::os::raw::c_uchar,
    pub version_minor: ::std::os::raw::c_uchar,
    pub version_subminor: ::std::os::raw::c_uchar,
    #[doc = "The encoded frame width.\n This must be a multiple of 16, and less than 1048576."]
    pub frame_width: ogg_uint32_t,
    #[doc = "The encoded frame height.\n This must be a multiple of 16, and less than 1048576."]
    pub frame_height: ogg_uint32_t,
    #[doc = "The displayed picture width.\n This must be no larger than width."]
    pub pic_width: ogg_uint32_t,
    #[doc = "The displayed picture height.\n This must be no larger than height."]
    pub pic_height: ogg_uint32_t,
    #[doc = "The X offset of the displayed picture.\n This must be no larger than #frame_width-#pic_width or 255, whichever is\n  smaller."]
    pub pic_x: ogg_uint32_t,
    #[doc = "The Y offset of the displayed picture.\n This must be no larger than #frame_height-#pic_height, and\n  #frame_height-#pic_height-#pic_y must be no larger than 255.\n This slightly funny restriction is due to the fact that the offset is\n  specified from the top of the image for consistency with the standard\n  graphics left-handed coordinate system used throughout this API, while\n  it is stored in the encoded stream as an offset from the bottom."]
    pub pic_y: ogg_uint32_t,
    pub fps_numerator: ogg_uint32_t,
    pub fps_denominator: ogg_uint32_t,
    pub aspect_numerator: ogg_uint32_t,
    pub aspect_denominator: ogg_uint32_t,
    #[doc = "The color space."]
    pub colorspace: th_colorspace,
    #[doc = "The pixel format."]
    pub pixel_fmt: th_pixel_fmt,
    #[doc = "The target bit-rate in bits per second.\nIf initializing an encoder with this struct, set this field to a non-zero\nvalue to activate CBR encoding by default."]
    pub target_bitrate: ::std::os::raw::c_int,
    #[doc = "The target quality level.\nValid values range from 0 to 63, inclusive, with higher values giving\nhigher quality.\nIf initializing an encoder with this struct, and #target_bitrate is set\nto zero, VBR encoding at this quality will be activated by default."]
    pub quality: ::std::os::raw::c_int,
    #[doc = "The amount to shift to extract the last keyframe number from the granule\n  position.\n This can be at most 31.\n th_info_init() will set this to a default value (currently <tt>6</tt>,\n  which is good for streaming applications), but you can set it to 0 to\n  make every frame a keyframe.\n The maximum distance between key frames is\n  <tt>1<<#keyframe_granule_shift</tt>.\n The keyframe frequency can be more finely controlled with\n  #TH_ENCCTL_SET_KEYFRAME_FREQUENCY_FORCE, which can also be adjusted\n  during encoding (for example, to force the next frame to be a keyframe),\n  but it cannot be set larger than the amount permitted by this field after\n  the headers have been output."]
    pub keyframe_granule_shift: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_th_info() {
    const UNINIT: ::std::mem::MaybeUninit<th_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_info>(),
        64usize,
        concat!("Size of: ", stringify!(th_info))
    );
    assert_eq!(
        ::std::mem::align_of::<th_info>(),
        4usize,
        concat!("Alignment of ", stringify!(th_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version_subminor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(version_subminor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(frame_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(frame_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_width) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(pic_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(pic_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(pic_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pic_y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(pic_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_numerator) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(fps_numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fps_denominator) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(fps_denominator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_numerator) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(aspect_numerator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aspect_denominator) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(aspect_denominator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).colorspace) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixel_fmt) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(pixel_fmt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_bitrate) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(target_bitrate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quality) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyframe_granule_shift) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(th_info),
            "::",
            stringify!(keyframe_granule_shift)
        )
    );
}
#[doc = "The comment information.\n\n This structure holds the in-stream metadata corresponding to\n  the 'comment' header packet.\n The comment header is meant to be used much like someone jotting a quick\n  note on the label of a video.\n It should be a short, to the point text note that can be more than a couple\n  words, but not more than a short paragraph.\n\n The metadata is stored as a series of (tag, value) pairs, in\n  length-encoded string vectors.\n The first occurrence of the '=' character delimits the tag and value.\n A particular tag may occur more than once, and order is significant.\n The character set encoding for the strings is always UTF-8, but the tag\n  names are limited to ASCII, and treated as case-insensitive.\n See <a href=\"http://www.theora.org/doc/Theora.pdf\">the Theora\n  specification</a>, Section 6.3.3 for details.\n\n In filling in this structure, th_decode_headerin() will null-terminate\n  the user_comment strings for safety.\n However, the bitstream format itself treats them as 8-bit clean vectors,\n  possibly containing null characters, so the length array should be\n  treated as their authoritative length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_comment {
    #[doc = "The array of comment string vectors."]
    pub user_comments: *mut *mut ::std::os::raw::c_char,
    #[doc = "An array of the corresponding length of each vector, in bytes."]
    pub comment_lengths: *mut ::std::os::raw::c_int,
    #[doc = "The total number of comment strings."]
    pub comments: ::std::os::raw::c_int,
    #[doc = "The null-terminated vendor string.\nThis identifies the software used to encode the stream."]
    pub vendor: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_th_comment() {
    const UNINIT: ::std::mem::MaybeUninit<th_comment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_comment>(),
        32usize,
        concat!("Size of: ", stringify!(th_comment))
    );
    assert_eq!(
        ::std::mem::align_of::<th_comment>(),
        8usize,
        concat!("Alignment of ", stringify!(th_comment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_comments) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_comment),
            "::",
            stringify!(user_comments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comment_lengths) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(th_comment),
            "::",
            stringify!(comment_lengths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comments) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(th_comment),
            "::",
            stringify!(comments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(th_comment),
            "::",
            stringify!(vendor)
        )
    );
}
#[doc = "A single base matrix."]
pub type th_quant_base = [::std::os::raw::c_uchar; 64usize];
#[doc = "A set of \\a qi ranges."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_quant_ranges {
    #[doc = "The number of ranges in the set."]
    pub nranges: ::std::os::raw::c_int,
    #[doc = "The size of each of the #nranges ranges.\nThese must sum to 63."]
    pub sizes: *const ::std::os::raw::c_int,
    #[doc = "#nranges <tt>+1</tt> base matrices.\nMatrices \\a i and <tt>i+1</tt> form the endpoints of range \\a i."]
    pub base_matrices: *const th_quant_base,
}
#[test]
fn bindgen_test_layout_th_quant_ranges() {
    const UNINIT: ::std::mem::MaybeUninit<th_quant_ranges> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_quant_ranges>(),
        24usize,
        concat!("Size of: ", stringify!(th_quant_ranges))
    );
    assert_eq!(
        ::std::mem::align_of::<th_quant_ranges>(),
        8usize,
        concat!("Alignment of ", stringify!(th_quant_ranges))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nranges) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_ranges),
            "::",
            stringify!(nranges)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_ranges),
            "::",
            stringify!(sizes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).base_matrices) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_ranges),
            "::",
            stringify!(base_matrices)
        )
    );
}
#[doc = "A complete set of quantization parameters.\nThe quantizer for each coefficient is calculated as:\n\\code\nQ=MAX(MIN(qmin[qti][ci!=0],scale[ci!=0][qi]*base[qti][pli][qi][ci]/100),\n1024).\n\\endcode\n\n\\a qti is the quantization type index: 0 for intra, 1 for inter.\n<tt>ci!=0</tt> is 0 for the DC coefficient and 1 for AC coefficients.\n\\a qi is the quality index, ranging between 0 (low quality) and 63 (high\nquality).\n\\a pli is the color plane index: 0 for Y', 1 for Cb, 2 for Cr.\n\\a ci is the DCT coefficient index.\nCoefficient indices correspond to the normal 2D DCT block\nordering--row-major with low frequencies first--\\em not zig-zag order.\n\nMinimum quantizers are constant, and are given by:\n\\code\nqmin[2][2]={{4,2},{8,4}}.\n\\endcode\n\nParameters that can be stored in the bitstream are as follows:\n- The two scale matrices ac_scale and dc_scale.\n\\code\nscale[2][64]={dc_scale,ac_scale}.\n\\endcode\n- The base matrices for each \\a qi, \\a qti and \\a pli (up to 384 in all).\nIn order to avoid storing a full 384 base matrices, only a sparse set of\nmatrices are stored, and the rest are linearly interpolated.\nThis is done as follows.\nFor each \\a qti and \\a pli, a series of \\a n \\a qi ranges is defined.\nThe size of each \\a qi range can vary arbitrarily, but they must sum to\n63.\nThen, <tt>n+1</tt> matrices are specified, one for each endpoint of the\nranges.\nFor interpolation purposes, each range's endpoints are the first \\a qi\nvalue it contains and one past the last \\a qi value it contains.\nFractional values are rounded to the nearest integer, with ties rounded\naway from zero.\n\nBase matrices are stored by reference, so if the same matrices are used\nmultiple times, they will only appear once in the bitstream.\nThe bitstream is also capable of omitting an entire set of ranges and\nits associated matrices if they are the same as either the previous\nset (indexed in row-major order) or if the inter set is the same as the\nintra set.\n\n- Loop filter limit values.\nThe same limits are used for the loop filter in all color planes, despite\npotentially differing levels of quantization in each.\n\nFor the current encoder, <tt>scale[ci!=0][qi]</tt> must be no greater\nthan <tt>scale[ci!=0][qi-1]</tt> and <tt>base[qti][pli][qi][ci]</tt> must\nbe no greater than <tt>base[qti][pli][qi-1][ci]</tt>.\nThese two conditions ensure that the actual quantizer for a given \\a qti,\n\\a pli, and \\a ci does not increase as \\a qi increases.\nThis is not required by the decoder."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_quant_info {
    #[doc = "The DC scaling factors."]
    pub dc_scale: [ogg_uint16_t; 64usize],
    #[doc = "The AC scaling factors."]
    pub ac_scale: [ogg_uint16_t; 64usize],
    #[doc = "The loop filter limit values."]
    pub loop_filter_limits: [::std::os::raw::c_uchar; 64usize],
    #[doc = "The \\a qi ranges for each \\a ci and \\a pli."]
    pub qi_ranges: [[th_quant_ranges; 3usize]; 2usize],
}
#[test]
fn bindgen_test_layout_th_quant_info() {
    const UNINIT: ::std::mem::MaybeUninit<th_quant_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_quant_info>(),
        464usize,
        concat!("Size of: ", stringify!(th_quant_info))
    );
    assert_eq!(
        ::std::mem::align_of::<th_quant_info>(),
        8usize,
        concat!("Alignment of ", stringify!(th_quant_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dc_scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_info),
            "::",
            stringify!(dc_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ac_scale) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_info),
            "::",
            stringify!(ac_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loop_filter_limits) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_info),
            "::",
            stringify!(loop_filter_limits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qi_ranges) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(th_quant_info),
            "::",
            stringify!(qi_ranges)
        )
    );
}
#[doc = "A Huffman code for a Theora DCT token.\n Each set of Huffman codes in a given table must form a complete, prefix-free\n  code.\n There is no requirement that all the tokens in a table have a valid code,\n  but the current encoder is not optimized to take advantage of this.\n If each of the five grouops of 16 tables does not contain at least one table\n  with a code for every token, then the encoder may fail to encode certain\n  frames.\n The complete table in the first group of 16 does not have to be in the same\n  place as the complete table in the other groups, but the complete tables in\n  the remaining four groups must all be in the same place."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_huff_code {
    #[doc = "The bit pattern for the code, with the LSbit of the pattern aligned in\n   the LSbit of the word."]
    pub pattern: ogg_uint32_t,
    #[doc = "The number of bits in the code.\n This must be between 0 and 32, inclusive."]
    pub nbits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_th_huff_code() {
    const UNINIT: ::std::mem::MaybeUninit<th_huff_code> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_huff_code>(),
        8usize,
        concat!("Size of: ", stringify!(th_huff_code))
    );
    assert_eq!(
        ::std::mem::align_of::<th_huff_code>(),
        4usize,
        concat!("Alignment of ", stringify!(th_huff_code))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pattern) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_huff_code),
            "::",
            stringify!(pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(th_huff_code),
            "::",
            stringify!(nbits)
        )
    );
}
extern "C" {
    #[doc = "Retrieves a human-readable string to identify the library vendor and\n  version.\n \\return the version string."]
    pub fn th_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Retrieves the library version number.\n This is the highest bitstream version that the encoder library will produce,\n  or that the decoder library can decode.\n This number is composed of a 16-bit major version, 8-bit minor version\n and 8 bit sub-version, composed as follows:\n \\code\n (VERSION_MAJOR<<16)+(VERSION_MINOR<<8)+(VERSION_SUBMINOR)\n \\endcode\n \\return the version number."]
    pub fn th_version_number() -> ogg_uint32_t;
}
extern "C" {
    #[doc = "Converts a granule position to an absolute frame index, starting at\n  <tt>0</tt>.\n The granule position is interpreted in the context of a given\n  #th_enc_ctx or #th_dec_ctx handle (either will suffice).\n \\param _encdec  A previously allocated #th_enc_ctx or #th_dec_ctx\n                  handle.\n \\param _granpos The granule position to convert.\n \\returns The absolute frame index corresponding to \\a _granpos.\n \\retval -1 The given granule position was invalid (i.e. negative)."]
    pub fn th_granule_frame(
        _encdec: *mut ::std::os::raw::c_void,
        _granpos: ogg_int64_t,
    ) -> ogg_int64_t;
}
extern "C" {
    #[doc = "Converts a granule position to an absolute time in seconds.\n The granule position is interpreted in the context of a given\n  #th_enc_ctx or #th_dec_ctx handle (either will suffice).\n \\param _encdec  A previously allocated #th_enc_ctx or #th_dec_ctx\n                  handle.\n \\param _granpos The granule position to convert.\n \\return The absolute time in seconds corresponding to \\a _granpos.\n         This is the \"end time\" for the frame, or the latest time it should\n          be displayed.\n         It is not the presentation time.\n \\retval -1 The given granule position was invalid (i.e. negative)."]
    pub fn th_granule_time(_encdec: *mut ::std::os::raw::c_void, _granpos: ogg_int64_t) -> f64;
}
extern "C" {
    #[doc = "Determines whether a Theora packet is a header or not.\n This function does no verification beyond checking the packet type bit, so\n  it should not be used for bitstream identification; use\n  th_decode_headerin() for that.\n As per the Theora specification, an empty (0-byte) packet is treated as a\n  data packet (a delta frame with no coded blocks).\n \\param _op An <tt>ogg_packet</tt> containing encoded Theora data.\n \\retval 1 The packet is a header packet\n \\retval 0 The packet is a video data packet."]
    pub fn th_packet_isheader(_op: *mut ogg_packet) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Determines whether a theora packet is a key frame or not.\n This function does no verification beyond checking the packet type and\n  key frame bits, so it should not be used for bitstream identification; use\n  th_decode_headerin() for that.\n As per the Theora specification, an empty (0-byte) packet is treated as a\n  delta frame (with no coded blocks).\n \\param _op An <tt>ogg_packet</tt> containing encoded Theora data.\n \\retval 1  The packet contains a key frame.\n \\retval 0  The packet contains a delta frame.\n \\retval -1 The packet is not a video data packet."]
    pub fn th_packet_iskeyframe(_op: *mut ogg_packet) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Initializes a th_info structure.\n This should be called on a freshly allocated #th_info structure before\n  attempting to use it.\n \\param _info The #th_info struct to initialize."]
    pub fn th_info_init(_info: *mut th_info);
}
extern "C" {
    #[doc = "Clears a #th_info structure.\n This should be called on a #th_info structure after it is no longer\n  needed.\n \\param _info The #th_info struct to clear."]
    pub fn th_info_clear(_info: *mut th_info);
}
extern "C" {
    #[doc = "Initialize a #th_comment structure.\n This should be called on a freshly allocated #th_comment structure\n  before attempting to use it.\n \\param _tc The #th_comment struct to initialize."]
    pub fn th_comment_init(_tc: *mut th_comment);
}
extern "C" {
    #[doc = "Add a comment to an initialized #th_comment structure.\n \\note Neither th_comment_add() nor th_comment_add_tag() support\n  comments containing null values, although the bitstream format does\n  support them.\n To add such comments you will need to manipulate the #th_comment\n  structure directly.\n \\param _tc      The #th_comment struct to add the comment to.\n \\param _comment Must be a null-terminated UTF-8 string containing the\n                  comment in \"TAG=the value\" form."]
    pub fn th_comment_add(_tc: *mut th_comment, _comment: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "Add a comment to an initialized #th_comment structure.\n \\note Neither th_comment_add() nor th_comment_add_tag() support\n  comments containing null values, although the bitstream format does\n  support them.\n To add such comments you will need to manipulate the #th_comment\n  structure directly.\n \\param _tc  The #th_comment struct to add the comment to.\n \\param _tag A null-terminated string containing the tag associated with\n              the comment.\n \\param _val The corresponding value as a null-terminated string."]
    pub fn th_comment_add_tag(
        _tc: *mut th_comment,
        _tag: *const ::std::os::raw::c_char,
        _val: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = "Look up a comment value by its tag.\n \\param _tc    An initialized #th_comment structure.\n \\param _tag   The tag to look up.\n \\param _count The instance of the tag.\n               The same tag can appear multiple times, each with a distinct\n                value, so an index is required to retrieve them all.\n               The order in which these values appear is significant and\n                should be preserved.\n               Use th_comment_query_count() to get the legal range for\n                the \\a _count parameter.\n \\return A pointer to the queried tag's value.\n         This points directly to data in the #th_comment structure.\n         It should not be modified or freed by the application, and\n          modifications to the structure may invalidate the pointer.\n \\retval NULL If no matching tag is found."]
    pub fn th_comment_query(
        _tc: *mut th_comment,
        _tag: *const ::std::os::raw::c_char,
        _count: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "Look up the number of instances of a tag.\n Call this first when querying for a specific tag and then iterate over the\n  number of instances with separate calls to th_comment_query() to\n  retrieve all the values for that tag in order.\n \\param _tc    An initialized #th_comment structure.\n \\param _tag   The tag to look up.\n \\return The number of instances of this particular tag."]
    pub fn th_comment_query_count(
        _tc: *mut th_comment,
        _tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Clears a #th_comment structure.\n This should be called on a #th_comment structure after it is no longer\n  needed.\n It will free all memory used by the structure members.\n \\param _tc The #th_comment struct to clear."]
    pub fn th_comment_clear(_tc: *mut th_comment);
}
#[doc = "A callback function for striped decode.\n This is a function pointer to an application-provided function that will be\n  called each time a section of the image is fully decoded in\n  th_decode_packetin().\n This allows the application to process the section immediately, while it is\n  still in cache.\n Note that the frame is decoded bottom to top, so \\a _yfrag0 will steadily\n  decrease with each call until it reaches 0, at which point the full frame\n  is decoded.\n The number of fragment rows made available in each call depends on the pixel\n  format and the number of post-processing filters enabled, and may not even\n  be constant for the entire frame.\n If a non-<tt>NULL</tt> \\a _granpos pointer is passed to\n  th_decode_packetin(), the granule position for the frame will be stored\n  in it before the first callback is made.\n If an entire frame is dropped (a 0-byte packet), then no callbacks will be\n  made at all for that frame.\n \\param _ctx       An application-provided context pointer.\n \\param _buf       The image buffer for the decoded frame.\n \\param _yfrag0    The Y coordinate of the first row of 8x8 fragments\n                    decoded.\n                   Multiply this by 8 to obtain the pixel row number in the\n                    luma plane.\n                   If the chroma planes are subsampled in the Y direction,\n                    this will always be divisible by two.\n \\param _yfrag_end The Y coordinate of the first row of 8x8 fragments past\n                    the newly decoded section.\n                   If the chroma planes are subsampled in the Y direction,\n                    this will always be divisible by two.\n                   I.e., this section contains fragment rows\n                    <tt>\\a _yfrag0 ...\\a _yfrag_end -1</tt>."]
pub type th_stripe_decoded_func = ::std::option::Option<
    unsafe extern "C" fn(
        _ctx: *mut ::std::os::raw::c_void,
        _buf: *mut th_img_plane,
        _yfrag0: ::std::os::raw::c_int,
        _yfrag_end: ::std::os::raw::c_int,
    ),
>;
#[doc = "The striped decode callback data to pass to #TH_DECCTL_SET_STRIPE_CB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_stripe_callback {
    #[doc = "An application-provided context pointer.\n This will be passed back verbatim to the application."]
    pub ctx: *mut ::std::os::raw::c_void,
    #[doc = "The callback function pointer."]
    pub stripe_decoded: th_stripe_decoded_func,
}
#[test]
fn bindgen_test_layout_th_stripe_callback() {
    const UNINIT: ::std::mem::MaybeUninit<th_stripe_callback> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<th_stripe_callback>(),
        16usize,
        concat!("Size of: ", stringify!(th_stripe_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<th_stripe_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(th_stripe_callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(th_stripe_callback),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stripe_decoded) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(th_stripe_callback),
            "::",
            stringify!(stripe_decoded)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_dec_ctx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct th_setup_info {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "Decodes the header packets of a Theora stream.\n This should be called on the initial packets of the stream, in succession,\n  until it returns <tt>0</tt>, indicating that all headers have been\n  processed, or an error is encountered.\n At least three header packets are required, and additional optional header\n  packets may follow.\n This can be used on the first packet of any logical stream to determine if\n  that stream is a Theora stream.\n \\param _info  A #th_info structure to fill in.\n               This must have been previously initialized with\n                th_info_init().\n               The application may immediately begin using the contents of\n                this structure after the first header is decoded, though it\n                must continue to be passed in on all subsequent calls.\n \\param _tc    A #th_comment structure to fill in.\n               The application may immediately begin using the contents of\n                this structure after the second header is decoded, though it\n                must continue to be passed in on all subsequent calls.\n \\param _setup Returns a pointer to additional, private setup information\n                needed by the decoder.\n               The contents of this pointer must be initialized to\n                <tt>NULL</tt> on the first call, and the returned value must\n                continue to be passed in on all subsequent calls.\n \\param _op    An <tt>ogg_packet</tt> structure which contains one of the\n                initial packets of an Ogg logical stream.\n \\return A positive value indicates that a Theora header was successfully\n          processed.\n \\retval 0             The first video data packet was encountered after all\n                        required header packets were parsed.\n                       The packet just passed in on this call should be saved\n                        and fed to th_decode_packetin() to begin decoding\n                        video data.\n \\retval TH_EFAULT     One of \\a _info, \\a _tc, or \\a _setup was\n                        <tt>NULL</tt>.\n \\retval TH_EBADHEADER \\a _op was <tt>NULL</tt>, the packet was not the next\n                        header packet in the expected sequence, or the format\n                        of the header data was invalid.\n \\retval TH_EVERSION   The packet data was a Theora info header, but for a\n                        bitstream version not decodable with this version of\n                        <tt>libtheoradec</tt>.\n \\retval TH_ENOTFORMAT The packet was not a Theora header."]
    pub fn th_decode_headerin(
        _info: *mut th_info,
        _tc: *mut th_comment,
        _setup: *mut *mut th_setup_info,
        _op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Allocates a decoder instance.\n\n <b>Security Warning:</b> The Theora format supports very large frame sizes,\n  potentially even larger than the address space of a 32-bit machine, and\n  creating a decoder context allocates the space for several frames of data.\n If the allocation fails here, your program will crash, possibly at some\n  future point because the OS kernel returned a valid memory range and will\n  only fail when it tries to map the pages in it the first time they are\n  used.\n Even if it succeeds, you may experience a denial of service if the frame\n  size is large enough to cause excessive paging.\n If you are integrating libtheora in a larger application where such things\n  are undesirable, it is highly recommended that you check the frame size in\n  \\a _info before calling this function and refuse to decode streams where it\n  is larger than some reasonable maximum.\n libtheora will not check this for you, because there may be machines that\n  can handle such streams and applications that wish to.\n \\param _info  A #th_info struct filled via th_decode_headerin().\n \\param _setup A #th_setup_info handle returned via\n                th_decode_headerin().\n \\return The initialized #th_dec_ctx handle.\n \\retval NULL If the decoding parameters were invalid."]
    pub fn th_decode_alloc(_info: *const th_info, _setup: *const th_setup_info) -> *mut th_dec_ctx;
}
extern "C" {
    #[doc = "Releases all storage used for the decoder setup information.\n This should be called after you no longer want to create any decoders for\n  a stream whose headers you have parsed with th_decode_headerin().\n \\param _setup The setup information to free.\n               This can safely be <tt>NULL</tt>."]
    pub fn th_setup_free(_setup: *mut th_setup_info);
}
extern "C" {
    #[doc = "Decoder control function.\n This is used to provide advanced control of the decoding process.\n \\param _dec    A #th_dec_ctx handle.\n \\param _req    The control code to process.\n                See \\ref decctlcodes \"the list of available control codes\"\n                 for details.\n \\param _buf    The parameters for this control code.\n \\param _buf_sz The size of the parameter buffer.\n \\return Possible return values depend on the control code used.\n          See \\ref decctlcodes \"the list of control codes\" for\n          specific values. Generally 0 indicates success."]
    pub fn th_decode_ctl(
        _dec: *mut th_dec_ctx,
        _req: ::std::os::raw::c_int,
        _buf: *mut ::std::os::raw::c_void,
        _buf_sz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Submits a packet containing encoded video data to the decoder.\n \\param _dec     A #th_dec_ctx handle.\n \\param _op      An <tt>ogg_packet</tt> containing encoded video data.\n \\param _granpos Returns the granule position of the decoded packet.\n                 If non-<tt>NULL</tt>, the granule position for this specific\n                  packet is stored in this location.\n                 This is computed incrementally from previously decoded\n                  packets.\n                 After a seek, the correct granule position must be set via\n                  #TH_DECCTL_SET_GRANPOS for this to work properly.\n \\retval 0             Success.\n                       A new decoded frame can be retrieved by calling\n                        th_decode_ycbcr_out().\n \\retval TH_DUPFRAME   The packet represented a dropped frame (either a\n                        0-byte frame or an INTER frame with no coded blocks).\n                       The player can skip the call to th_decode_ycbcr_out(),\n                        as the contents of the decoded frame buffer have not\n                        changed.\n \\retval TH_EFAULT     \\a _dec or \\a _op was <tt>NULL</tt>.\n \\retval TH_EBADPACKET \\a _op does not contain encoded video data.\n \\retval TH_EIMPL      The video data uses bitstream features which this\n                        library does not support."]
    pub fn th_decode_packetin(
        _dec: *mut th_dec_ctx,
        _op: *const ogg_packet,
        _granpos: *mut ogg_int64_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Outputs the next available frame of decoded Y'CbCr data.\n If a striped decode callback has been set with #TH_DECCTL_SET_STRIPE_CB,\n  then the application does not need to call this function.\n \\param _dec   A #th_dec_ctx handle.\n \\param _ycbcr A video buffer structure to fill in.\n               <tt>libtheoradec</tt> will fill in all the members of this\n                structure, including the pointers to the uncompressed video\n                data.\n               The memory for this video data is owned by\n                <tt>libtheoradec</tt>.\n               It may be freed or overwritten without notification when\n                subsequent frames are decoded.\n \\retval 0 Success\n \\retval TH_EFAULT     \\a _dec or \\a _ycbcr was <tt>NULL</tt>."]
    pub fn th_decode_ycbcr_out(
        _dec: *mut th_dec_ctx,
        _ycbcr: *mut th_img_plane,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Frees an allocated decoder instance.\n \\param _dec A #th_dec_ctx handle."]
    pub fn th_decode_free(_dec: *mut th_dec_ctx);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vorbis_info {
    pub version: ::std::os::raw::c_int,
    pub channels: ::std::os::raw::c_int,
    pub rate: ::std::os::raw::c_long,
    pub bitrate_upper: ::std::os::raw::c_long,
    pub bitrate_nominal: ::std::os::raw::c_long,
    pub bitrate_lower: ::std::os::raw::c_long,
    pub bitrate_window: ::std::os::raw::c_long,
    pub codec_setup: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vorbis_info() {
    const UNINIT: ::std::mem::MaybeUninit<vorbis_info> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vorbis_info>(),
        56usize,
        concat!("Size of: ", stringify!(vorbis_info))
    );
    assert_eq!(
        ::std::mem::align_of::<vorbis_info>(),
        8usize,
        concat!("Alignment of ", stringify!(vorbis_info))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate_upper) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(bitrate_upper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate_nominal) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(bitrate_nominal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate_lower) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(bitrate_lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitrate_window) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(bitrate_window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_setup) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_info),
            "::",
            stringify!(codec_setup)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vorbis_dsp_state {
    pub analysisp: ::std::os::raw::c_int,
    pub vi: *mut vorbis_info,
    pub pcm: *mut *mut f32,
    pub pcmret: *mut *mut f32,
    pub pcm_storage: ::std::os::raw::c_int,
    pub pcm_current: ::std::os::raw::c_int,
    pub pcm_returned: ::std::os::raw::c_int,
    pub preextrapolate: ::std::os::raw::c_int,
    pub eofflag: ::std::os::raw::c_int,
    pub lW: ::std::os::raw::c_long,
    pub W: ::std::os::raw::c_long,
    pub nW: ::std::os::raw::c_long,
    pub centerW: ::std::os::raw::c_long,
    pub granulepos: ogg_int64_t,
    pub sequence: ogg_int64_t,
    pub glue_bits: ogg_int64_t,
    pub time_bits: ogg_int64_t,
    pub floor_bits: ogg_int64_t,
    pub res_bits: ogg_int64_t,
    pub backend_state: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vorbis_dsp_state() {
    const UNINIT: ::std::mem::MaybeUninit<vorbis_dsp_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vorbis_dsp_state>(),
        144usize,
        concat!("Size of: ", stringify!(vorbis_dsp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<vorbis_dsp_state>(),
        8usize,
        concat!("Alignment of ", stringify!(vorbis_dsp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).analysisp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(analysisp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(vi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcm) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(pcm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcmret) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(pcmret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcm_storage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(pcm_storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcm_current) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(pcm_current)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcm_returned) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(pcm_returned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preextrapolate) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(preextrapolate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eofflag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(eofflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lW) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(lW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(W)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nW) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(nW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).centerW) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(centerW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granulepos) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(granulepos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glue_bits) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(glue_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_bits) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(time_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).floor_bits) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(floor_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_bits) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(res_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend_state) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_dsp_state),
            "::",
            stringify!(backend_state)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vorbis_block {
    pub pcm: *mut *mut f32,
    pub opb: oggpack_buffer,
    pub lW: ::std::os::raw::c_long,
    pub W: ::std::os::raw::c_long,
    pub nW: ::std::os::raw::c_long,
    pub pcmend: ::std::os::raw::c_int,
    pub mode: ::std::os::raw::c_int,
    pub eofflag: ::std::os::raw::c_int,
    pub granulepos: ogg_int64_t,
    pub sequence: ogg_int64_t,
    pub vd: *mut vorbis_dsp_state,
    pub localstore: *mut ::std::os::raw::c_void,
    pub localtop: ::std::os::raw::c_long,
    pub localalloc: ::std::os::raw::c_long,
    pub totaluse: ::std::os::raw::c_long,
    pub reap: *mut alloc_chain,
    pub glue_bits: ::std::os::raw::c_long,
    pub time_bits: ::std::os::raw::c_long,
    pub floor_bits: ::std::os::raw::c_long,
    pub res_bits: ::std::os::raw::c_long,
    pub internal: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_vorbis_block() {
    const UNINIT: ::std::mem::MaybeUninit<vorbis_block> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vorbis_block>(),
        192usize,
        concat!("Size of: ", stringify!(vorbis_block))
    );
    assert_eq!(
        ::std::mem::align_of::<vorbis_block>(),
        8usize,
        concat!("Alignment of ", stringify!(vorbis_block))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(pcm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opb) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(opb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lW) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(lW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(W)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nW) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(nW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pcmend) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(pcmend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eofflag) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(eofflag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).granulepos) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(granulepos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sequence) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(vd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localstore) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(localstore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localtop) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(localtop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).localalloc) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(localalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totaluse) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(totaluse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reap) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(reap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).glue_bits) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(glue_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_bits) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(time_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).floor_bits) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(floor_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_bits) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(res_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_block),
            "::",
            stringify!(internal)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct alloc_chain {
    pub ptr: *mut ::std::os::raw::c_void,
    pub next: *mut alloc_chain,
}
#[test]
fn bindgen_test_layout_alloc_chain() {
    const UNINIT: ::std::mem::MaybeUninit<alloc_chain> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<alloc_chain>(),
        16usize,
        concat!("Size of: ", stringify!(alloc_chain))
    );
    assert_eq!(
        ::std::mem::align_of::<alloc_chain>(),
        8usize,
        concat!("Alignment of ", stringify!(alloc_chain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(alloc_chain),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(alloc_chain),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vorbis_comment {
    pub user_comments: *mut *mut ::std::os::raw::c_char,
    pub comment_lengths: *mut ::std::os::raw::c_int,
    pub comments: ::std::os::raw::c_int,
    pub vendor: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_vorbis_comment() {
    const UNINIT: ::std::mem::MaybeUninit<vorbis_comment> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<vorbis_comment>(),
        32usize,
        concat!("Size of: ", stringify!(vorbis_comment))
    );
    assert_eq!(
        ::std::mem::align_of::<vorbis_comment>(),
        8usize,
        concat!("Alignment of ", stringify!(vorbis_comment))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_comments) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_comment),
            "::",
            stringify!(user_comments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comment_lengths) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_comment),
            "::",
            stringify!(comment_lengths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).comments) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_comment),
            "::",
            stringify!(comments)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vendor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vorbis_comment),
            "::",
            stringify!(vendor)
        )
    );
}
extern "C" {
    pub fn vorbis_info_init(vi: *mut vorbis_info);
}
extern "C" {
    pub fn vorbis_info_clear(vi: *mut vorbis_info);
}
extern "C" {
    pub fn vorbis_info_blocksize(
        vi: *mut vorbis_info,
        zo: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_comment_init(vc: *mut vorbis_comment);
}
extern "C" {
    pub fn vorbis_comment_add(vc: *mut vorbis_comment, comment: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn vorbis_comment_add_tag(
        vc: *mut vorbis_comment,
        tag: *const ::std::os::raw::c_char,
        contents: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn vorbis_comment_query(
        vc: *mut vorbis_comment,
        tag: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn vorbis_comment_query_count(
        vc: *mut vorbis_comment,
        tag: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_comment_clear(vc: *mut vorbis_comment);
}
extern "C" {
    pub fn vorbis_block_init(
        v: *mut vorbis_dsp_state,
        vb: *mut vorbis_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_block_clear(vb: *mut vorbis_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_dsp_clear(v: *mut vorbis_dsp_state);
}
extern "C" {
    pub fn vorbis_granule_time(v: *mut vorbis_dsp_state, granulepos: ogg_int64_t) -> f64;
}
extern "C" {
    pub fn vorbis_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn vorbis_analysis_init(
        v: *mut vorbis_dsp_state,
        vi: *mut vorbis_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_commentheader_out(
        vc: *mut vorbis_comment,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_analysis_headerout(
        v: *mut vorbis_dsp_state,
        vc: *mut vorbis_comment,
        op: *mut ogg_packet,
        op_comm: *mut ogg_packet,
        op_code: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_analysis_buffer(
        v: *mut vorbis_dsp_state,
        vals: ::std::os::raw::c_int,
    ) -> *mut *mut f32;
}
extern "C" {
    pub fn vorbis_analysis_wrote(
        v: *mut vorbis_dsp_state,
        vals: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_analysis_blockout(
        v: *mut vorbis_dsp_state,
        vb: *mut vorbis_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_analysis(vb: *mut vorbis_block, op: *mut ogg_packet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_bitrate_addblock(vb: *mut vorbis_block) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_bitrate_flushpacket(
        vd: *mut vorbis_dsp_state,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_idheader(op: *mut ogg_packet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_headerin(
        vi: *mut vorbis_info,
        vc: *mut vorbis_comment,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_init(
        v: *mut vorbis_dsp_state,
        vi: *mut vorbis_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_restart(v: *mut vorbis_dsp_state) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis(vb: *mut vorbis_block, op: *mut ogg_packet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_trackonly(
        vb: *mut vorbis_block,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_blockin(
        v: *mut vorbis_dsp_state,
        vb: *mut vorbis_block,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_pcmout(
        v: *mut vorbis_dsp_state,
        pcm: *mut *mut *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_lapout(
        v: *mut vorbis_dsp_state,
        pcm: *mut *mut *mut f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_read(
        v: *mut vorbis_dsp_state,
        samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_packet_blocksize(
        vi: *mut vorbis_info,
        op: *mut ogg_packet,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn vorbis_synthesis_halfrate(
        v: *mut vorbis_info,
        flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vorbis_synthesis_halfrate_p(v: *mut vorbis_info) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tf_callbacks {
    pub read_func: ::std::option::Option<
        unsafe extern "C" fn(
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
            nmemb: usize,
            datasource: *mut ::std::os::raw::c_void,
        ) -> usize,
    >,
    pub seek_func: ::std::option::Option<
        unsafe extern "C" fn(
            datasource: *mut ::std::os::raw::c_void,
            offset: ogg_int64_t,
            origin: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub close_func: ::std::option::Option<
        unsafe extern "C" fn(datasource: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout_tf_callbacks() {
    const UNINIT: ::std::mem::MaybeUninit<tf_callbacks> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tf_callbacks>(),
        24usize,
        concat!("Size of: ", stringify!(tf_callbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<tf_callbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(tf_callbacks))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tf_callbacks),
            "::",
            stringify!(read_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tf_callbacks),
            "::",
            stringify!(seek_func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tf_callbacks),
            "::",
            stringify!(close_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OggTheora_File {
    pub sync: ogg_sync_state,
    pub page: ogg_page,
    pub eos: ::std::os::raw::c_int,
    pub tpackets: ::std::os::raw::c_int,
    pub vpackets: ::std::os::raw::c_int,
    pub tstream: *mut ogg_stream_state,
    pub vstream: *mut ogg_stream_state,
    pub tinfo: *mut th_info,
    pub vinfo: *mut vorbis_info,
    pub tcomment: *mut th_comment,
    pub vcomment: *mut vorbis_comment,
    pub vtracks: ::std::os::raw::c_int,
    pub vtrack: ::std::os::raw::c_int,
    pub ttracks: ::std::os::raw::c_int,
    pub ttrack: ::std::os::raw::c_int,
    pub tdec: *mut *mut th_dec_ctx,
    pub vdsp_init: ::std::os::raw::c_int,
    pub vdsp: vorbis_dsp_state,
    pub vblock_init: ::std::os::raw::c_int,
    pub vblock: vorbis_block,
    pub io: tf_callbacks,
    pub datasource: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_OggTheora_File() {
    const UNINIT: ::std::mem::MaybeUninit<OggTheora_File> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<OggTheora_File>(),
        536usize,
        concat!("Size of: ", stringify!(OggTheora_File))
    );
    assert_eq!(
        ::std::mem::align_of::<OggTheora_File>(),
        8usize,
        concat!("Alignment of ", stringify!(OggTheora_File))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(sync)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).page) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(page)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eos) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(eos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tpackets) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(tpackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vpackets) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vpackets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tstream) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(tstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vstream) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vstream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tinfo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(tinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vinfo) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tcomment) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(tcomment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcomment) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vcomment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtracks) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vtracks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vtrack) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vtrack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttracks) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(ttracks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttrack) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(ttrack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tdec) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(tdec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdsp_init) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vdsp_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdsp) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vdsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vblock_init) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vblock_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vblock) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(vblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datasource) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(OggTheora_File),
            "::",
            stringify!(datasource)
        )
    );
}
extern "C" {
    pub fn tf_open_callbacks(
        datasource: *mut ::std::os::raw::c_void,
        file: *mut OggTheora_File,
        io: tf_callbacks,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_fopen(
        fname: *const ::std::os::raw::c_char,
        file: *mut OggTheora_File,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_close(file: *mut OggTheora_File);
}
extern "C" {
    pub fn tf_hasvideo(file: *mut OggTheora_File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_hasaudio(file: *mut OggTheora_File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_videoinfo(
        file: *mut OggTheora_File,
        width: *mut ::std::os::raw::c_int,
        height: *mut ::std::os::raw::c_int,
        fps: *mut f64,
        fmt: *mut th_pixel_fmt,
    );
}
extern "C" {
    pub fn tf_audioinfo(
        file: *mut OggTheora_File,
        channels: *mut ::std::os::raw::c_int,
        samplerate: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn tf_eos(file: *mut OggTheora_File) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_reset(file: *mut OggTheora_File);
}
extern "C" {
    pub fn tf_readvideo(
        file: *mut OggTheora_File,
        buffer: *mut ::std::os::raw::c_char,
        numframes: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_readaudio(
        file: *mut OggTheora_File,
        buffer: *mut f32,
        samples: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_setaudiotrack(
        file: *mut OggTheora_File,
        vtrack: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tf_setvideotrack(
        file: *mut OggTheora_File,
        ttrack: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
